#pragma kernel FeedForward

//TODO:: FIX MATRIX INFO TO PASS IN AS A STRUCTURED BUFFER AS MATRIX SIZES ARE NOT THE SAME AND TEST MORE THAN 8 BUFFERS SINCE D3D DONT SUPPORT IT MIGHT HAVE 
//TO PASS THEM ALL IN AS A STRUCT() BUT MIGHT HINDER PERFORMANCE

//Population Data
uint StructureLength;
uint StructureMinLength; //StructureLength - 1
StructuredBuffer<uint> Structure;
uint Population;

//From here onwards all structured buffers represent matrices for all networks, the structure is as follows:
//    Network
//    [
//        Matrices
//        [
//            Column values
//            [
//                Row values
//                [
//                ]
//            ]
//        ]
//    ]
//
//    This is stored in row major such that:
//     |  [Mat1, Mat1, Mat1] ---> +sizeof(Mat1) to get to next Network's Mat1
//     |  [Mat2, Mat2, Mat2]
//     V  [Mat3, Mat3, Mat3]
//    +sizeof(Mat1)*Population to get to next layer, Mat2

struct MatrixInfo
{
	uint Rows;
	uint Cols;
	uint Size;
	uint Offset; //Offset in memory for the buffers
};
 
//These 3 are technically all Nodes, just split into Input and Output for ease in memory (Node values dont have to be copied)
RWStructuredBuffer<float> Inputs;
RWStructuredBuffer<float> Nodes;
RWStructuredBuffer<float> Outputs;

RWStructuredBuffer<float> CellStates;

RWStructuredBuffer<float> InputWeights;
RWStructuredBuffer<float> InputStateWeights;
RWStructuredBuffer<float> InputBias;

RWStructuredBuffer<float> InputModulationWeights;
RWStructuredBuffer<float> InputModulationStateWeights;
RWStructuredBuffer<float> InputModulationBias;

RWStructuredBuffer<float> ForgetWeights;
RWStructuredBuffer<float> ForgetStateWeights;
RWStructuredBuffer<float> ForgetBias;

RWStructuredBuffer<float> OutputWeights;
RWStructuredBuffer<float> OutputStateWeights;
RWStructuredBuffer<float> OutputBias;

RWStructuredBuffer<MatrixInfo> NodeCellInfo; //Shares matrix info for CellState and Inputs-Nodes-Outputs (MatrixInfo for CellState is just offset by 1)
RWStructuredBuffer<MatrixInfo> WeightBiasInfo; //Shares matrix info for Weight-StateWeights-OutputBias, stored 1 after the other (3D array)
RWStructuredBuffer<MatrixInfo> GateInfo; //Matrix info for the gates => all gates are the same size so they can share the same MatrixInfo

//As per layer a gate is used only once and then disgarded the format is
//    Network
//    [
//        Column values
//        [
//            Row values
//            [
//            ]
//        ]
//    ]
//
//However the size of the matrix (column * row) needs to be able to store the largest gate size in the network
//    This is stored in row major such that:
//     |  [Mat1, Mat1, Mat1] ---> +sizeof(Mat1) to get to next Network's Mat1
//     |  [Mat2, Mat2, Mat2]
//     V  [Mat3, Mat3, Mat3]
//    +sizeof(Mat1)*Population to get to next layer, Mat2

uint MaxGateSize;
RWStructuredBuffer<float> InputGate;
RWStructuredBuffer<float> InputModulationGate;
RWStructuredBuffer<float> ForgetGate;
RWStructuredBuffer<float> OutputGate;

void MatrixMultiplication(RWStructuredBuffer<float> A, RWStructuredBuffer<float> B, RWStructuredBuffer<float> C, MatrixInfo AInfo, MatrixInfo BInfo, MatrixInfo CInfo)
{
	for (uint i = 0, COffset = 0; i < CInfo.Cols; i++)
	{
		for (uint j = 0; j < CInfo.Rows; j++, COffset++)
		{
			C[COffset] = 0;
			for (uint k = 0, AOffset = AInfo.Offset + j, BOffset = BInfo.Offset + i * BInfo.Rows; k < AInfo.Cols; k++, AOffset += AInfo.Rows, BOffset++)
			{
				C[COffset] += A[AOffset] * B[BOffset];
			}
		}
	}
}

void MatrixMultiplicationNoReset(RWStructuredBuffer<float> A, RWStructuredBuffer<float> B, RWStructuredBuffer<float> C, MatrixInfo AInfo, MatrixInfo BInfo, MatrixInfo CInfo)
{
	for (uint i = 0, COffset = 0; i < CInfo.Cols; i++)
	{
		for (uint j = 0; j < CInfo.Rows; j++, COffset++)
		{
			for (uint k = 0, AOffset = AInfo.Offset + j, BOffset = BInfo.Offset + i * BInfo.Rows; k < AInfo.Cols; k++, AOffset += AInfo.Rows, BOffset++)
			{
				C[COffset] += A[AOffset] * B[BOffset];
			}
		}
	}
}

void MatrixCWiseMultiplication(RWStructuredBuffer<float> A, RWStructuredBuffer<float> B, RWStructuredBuffer<float> C, MatrixInfo Info)
{
	for (uint i = 0, Offset = Info.Offset; i < Info.Size; i++, Offset++)
	{
		C[Offset] = A[Offset] * B[Offset];
	}
}
void MatrixCWiseMultiplicationCopy(RWStructuredBuffer<float> A, RWStructuredBuffer<float> B, RWStructuredBuffer<float> C, MatrixInfo Info)
{
	for (uint i = 0, Offset = Info.Offset; i < Info.Size; i++, Offset++)
	{
		float Result = A[Offset] * B[Offset];
		C[Offset] = Result;
		B[Offset] = Result;
	}
}

void MatrixAddition(RWStructuredBuffer<float> A, RWStructuredBuffer<float> B, RWStructuredBuffer<float> C, MatrixInfo Info)
{
	for (uint i = 0, Offset = Info.Offset; i < Info.Size; i++, Offset++)
	{
		C[Offset] = A[Offset] + B[Offset];
	}
}

void MatrixTanh(RWStructuredBuffer<float> A, MatrixInfo Info)
{
	for (uint i = 0, Offset = Info.Offset; i < Info.Size; i++, Offset++)
	{
		A[Offset] = tanh(A[Offset]);
	}
}

void MatrixSigmoid(RWStructuredBuffer<float> A, MatrixInfo Info)
{
	for (uint i = 0, Offset = Info.Offset; i < Info.Size; i++, Offset++)
	{
		float Expon = exp(A[Offset]);
		A[Offset] = Expon / (Expon + 1);
	}
}

[numthreads(1, 1, 1)]
void FeedForward(uint3 id : SV_DispatchThreadID)
{
	//id.x => which network

	//i = 0 case for Inputs
	
	for (uint i = 1, j = 2; i < StructureLength - 2; i++, j++)
	{
		MatrixInfo NodeInf = NodeCellInfo[i];
		MatrixInfo CellStateInf = NodeCellInfo[j];
		MatrixInfo WeightInf = WeightBiasInfo[i * 3];
		MatrixInfo WeightStateInf = WeightBiasInfo[i * 3 + 1];
		MatrixInfo BiasInf = WeightBiasInfo[i * 3 + 2];
		MatrixInfo GateInf = GateInfo[i];

		//TODO:: handle offsets

		MatrixMultiplication(Nodes, InputWeights, InputGate, NodeInf, WeightInf, GateInf);
	}

	//i = length - 1 case for Outputs

}
